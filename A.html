<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4人将棋</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 900px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .game-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2em;
            color: #555;
            font-weight: bold;
        }
        
        .turn-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 5px;
            margin-left: 10px;
        }
        
        .player1-turn { background: #ffeb3b; color: #333; }
        .player2-turn { background: #2196f3; color: white; }
        .player3-turn { background: #4caf50; color: white; }
        .player4-turn { background: #ff5722; color: white; }
        
        .board-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin: 20px auto;
        }
        
        .player-area {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .player-area.top {
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .player-area.right {
            right: -150px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .player-area.bottom {
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .player-area.left {
            left: -150px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .player-label {
            font-weight: bold;
            padding: 5px 15px;
            border-radius: 5px;
            font-size: 1em;
            white-space: nowrap;
        }
        
        .player1-label { background: #ffeb3b; color: #333; }
        .player2-label { background: #2196f3; color: white; }
        .player3-label { background: #4caf50; color: white; }
        .player4-label { background: #ff5722; color: white; }
        
        .captured-pieces {
            min-width: 120px;
            min-height: 40px;
            background: #f5f5f5;
            border: 2px solid #999;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(9, 55px);
            grid-template-rows: repeat(9, 55px);
            background: #d4a574;
            border: 3px solid #8b4513;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .cell {
            width: 55px;
            height: 55px;
            border: 1px solid #8b4513;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            background: #d4a574;
        }
        
        .cell:hover {
            background: #e0ba8e;
        }
        
        .cell.selected {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        
        .cell.valid-move {
            background: #90EE90 !important;
        }
        
        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(0,128,0,0.5);
            border-radius: 50%;
        }
        
        .piece {
            width: 45px;
            height: 45px;
            background: #fff;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .piece.player1 { color: #000; border-color: #ffeb3b; }
        .piece.player2 { color: #000; border-color: #2196f3; transform: rotate(180deg); }
        .piece.player3 { color: #000; border-color: #4caf50; }
        .piece.player4 { color: #000; border-color: #ff5722; transform: rotate(180deg); }
        
        .piece.promoted {
            background: #ffe0b2;
        }
        
        .captured-piece {
            width: 35px;
            height: 35px;
            font-size: 14px;
            margin: 2px;
            cursor: pointer;
        }
        
        .captured-piece.player2,
        .captured-piece.player4 {
            transform: rotate(0deg) !important;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 30px;
            font-size: 1.1em;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .reset-btn {
            background: #4CAF50;
        }
        
        .reset-btn:hover {
            background: #45a049;
        }
        
        .undo-btn {
            background: #ff9800;
        }
        
        .undo-btn:hover {
            background: #f57c00;
        }
        
        .undo-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.1em;
            color: #d32f2f;
            font-weight: bold;
            min-height: 25px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>4人将棋</h1>
        <div class="game-info">
            現在の手番: <span class="turn-indicator" id="turnIndicator">プレイヤー1</span>
        </div>
        
        <div class="board-wrapper">
            <!-- プレイヤー2（上） -->
            <div class="player-area top">
                <div class="captured-pieces" id="player2Captured"></div>
                <div class="player-label player2-label">プレイヤー2</div>
            </div>
            
            <!-- プレイヤー3（右） -->
            <div class="player-area right">
                <div class="player-label player3-label">プレイヤー3</div>
                <div class="captured-pieces" id="player3Captured"></div>
            </div>
            
            <!-- プレイヤー4（左） -->
            <div class="player-area left">
                <div class="captured-pieces" id="player4Captured"></div>
                <div class="player-label player4-label">プレイヤー4</div>
            </div>
            
            <!-- 将棋盤 -->
            <div class="board" id="board"></div>
            
            <!-- プレイヤー1（下） -->
            <div class="player-area bottom">
                <div class="player-label player1-label">プレイヤー1</div>
                <div class="captured-pieces" id="player1Captured"></div>
            </div>
        </div>
        
        <div class="message" id="message"></div>
        
        <div class="controls">
            <button class="btn undo-btn" id="undoBtn" onclick="undoMove()">待った</button>
            <button class="btn reset-btn" onclick="resetGame()">新しいゲーム</button>
        </div>
    </div>

    <script>
        // 駒の定義
        const PIECES = {
            '王将': { name: '王将', promoted: null, moves: 'king', abbr: '王' },
            '飛車': { name: '飛車', promoted: '龍王', moves: 'rook', abbr: '飛' },
            '角行': { name: '角行', promoted: '龍馬', moves: 'bishop', abbr: '角' },
            '金将': { name: '金将', promoted: null, moves: 'gold', abbr: '金' },
            '銀将': { name: '銀将', promoted: '成銀', moves: 'silver', abbr: '銀' },
            '桂馬': { name: '桂馬', promoted: '成桂', moves: 'knight', abbr: '桂' },
            '香車': { name: '香車', promoted: '成香', moves: 'lance', abbr: '香' },
            '歩兵': { name: '歩兵', promoted: 'と金', moves: 'pawn', abbr: '歩' },
            '龍王': { name: '龍王', promoted: null, moves: 'promoted_rook', abbr: '龍' },
            '龍馬': { name: '龍馬', promoted: null, moves: 'promoted_bishop', abbr: '馬' },
            '成銀': { name: '成銀', promoted: null, moves: 'gold', abbr: '成銀' },
            '成桂': { name: '成桂', promoted: null, moves: 'gold', abbr: '成桂' },
            '成香': { name: '成香', promoted: null, moves: 'gold', abbr: '成香' },
            'と金': { name: 'と金', promoted: null, moves: 'gold', abbr: 'と' },
            '玉将': { name: '玉将', promoted: null, moves: 'king', abbr: '玉' }
        };

        let board = Array(9).fill(null).map(() => Array(9).fill(null));
        let selectedPiece = null;
        let selectedPos = null;
        let currentTurn = 'player1'; // player1, player2, player3, player4
        let capturedPieces = { player1: [], player2: [], player3: [], player4: [] };
        let validMoves = [];
        let moveHistory = [];

        // 初期配置
        function initBoard() {
            board = Array(9).fill(null).map(() => Array(9).fill(null));
            capturedPieces = { player1: [], player2: [], player3: [], player4: [] };
            currentTurn = 'player1';
            moveHistory = [];
            
            // プレイヤー2の駒配置（上側）
            board[0] = [
                {piece: '香車', owner: 'player2'},
                {piece: '桂馬', owner: 'player2'},
                {piece: '銀将', owner: 'player2'},
                {piece: '金将', owner: 'player2'},
                {piece: '玉将', owner: 'player2'},
                {piece: '金将', owner: 'player2'},
                {piece: '銀将', owner: 'player2'},
                {piece: '桂馬', owner: 'player2'},
                {piece: '香車', owner: 'player2'}
            ];
            board[1][1] = {piece: '飛車', owner: 'player2'};
            board[1][7] = {piece: '角行', owner: 'player2'};
            for (let i = 0; i < 9; i++) {
                board[2][i] = {piece: '歩兵', owner: 'player2'};
            }
            
            // プレイヤー1の駒配置（下側）
            for (let i = 0; i < 9; i++) {
                board[6][i] = {piece: '歩兵', owner: 'player1'};
            }
            board[7][7] = {piece: '飛車', owner: 'player1'};
            board[7][1] = {piece: '角行', owner: 'player1'};
            board[8] = [
                {piece: '香車', owner: 'player1'},
                {piece: '桂馬', owner: 'player1'},
                {piece: '銀将', owner: 'player1'},
                {piece: '金将', owner: 'player1'},
                {piece: '王将', owner: 'player1'},
                {piece: '金将', owner: 'player1'},
                {piece: '銀将', owner: 'player1'},
                {piece: '桂馬', owner: 'player1'},
                {piece: '香車', owner: 'player1'}
            ];
            
            // プレイヤー4の駒配置（左側）
            for (let i = 0; i < 9; i++) {
                board[i][0] = {piece: '歩兵', owner: 'player4'};
            }
            board[1][1] = {piece: '角行', owner: 'player4'};
            board[7][1] = {piece: '飛車', owner: 'player4'};
            
            // プレイヤー3の駒配置（右側）
            for (let i = 0; i < 9; i++) {
                board[i][8] = {piece: '歩兵', owner: 'player3'};
            }
            board[1][7] = {piece: '飛車', owner: 'player3'};
            board[7][7] = {piece: '角行', owner: 'player3'};
        }

        // 駒の移動方向を取得
        function getDirection(owner) {
            switch(owner) {
                case 'player1': return {row: -1, col: 0}; // 上
                case 'player2': return {row: 1, col: 0};  // 下
                case 'player3': return {row: 0, col: -1}; // 左
                case 'player4': return {row: 0, col: 1};  // 右
            }
        }

        // 駒の移動可能な位置を計算
        function getValidMoves(row, col, piece, owner) {
            const moves = [];
            const dir = getDirection(owner);
            const pieceType = PIECES[piece].moves;
            
            switch(pieceType) {
                case 'king':
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            addIfValid(moves, row + dr, col + dc, owner);
                        }
                    }
                    break;
                    
                case 'rook':
                    addLine(moves, row, col, owner, [-1,0], [1,0], [0,-1], [0,1]);
                    break;
                    
                case 'bishop':
                    addLine(moves, row, col, owner, [-1,-1], [-1,1], [1,-1], [1,1]);
                    break;
                    
                case 'promoted_rook':
                    addLine(moves, row, col, owner, [-1,0], [1,0], [0,-1], [0,1]);
                    addIfValid(moves, row-1, col-1, owner);
                    addIfValid(moves, row-1, col+1, owner);
                    addIfValid(moves, row+1, col-1, owner);
                    addIfValid(moves, row+1, col+1, owner);
                    break;
                    
                case 'promoted_bishop':
                    addLine(moves, row, col, owner, [-1,-1], [-1,1], [1,-1], [1,1]);
                    addIfValid(moves, row-1, col, owner);
                    addIfValid(moves, row+1, col, owner);
                    addIfValid(moves, row, col-1, owner);
                    addIfValid(moves, row, col+1, owner);
                    break;
                    
                case 'gold':
                    addIfValid(moves, row+dir.row, col+dir.col, owner);
                    addIfValid(moves, row+dir.row, col+dir.col-1, owner);
                    addIfValid(moves, row+dir.row, col+dir.col+1, owner);
                    addIfValid(moves, row-dir.row, col-dir.col, owner);
                    addIfValid(moves, row, col-1, owner);
                    addIfValid(moves, row, col+1, owner);
                    break;
                    
                case 'silver':
                    addIfValid(moves, row+dir.row, col+dir.col, owner);
                    addIfValid(moves, row+dir.row, col+dir.col-1, owner);
                    addIfValid(moves, row+dir.row, col+dir.col+1, owner);
                    addIfValid(moves, row-dir.row, col-dir.col-1, owner);
                    addIfValid(moves, row-dir.row, col-dir.col+1, owner);
                    break;
                    
                case 'knight':
                    if (owner === 'player1' || owner === 'player2') {
                        addIfValid(moves, row+2*dir.row, col-1, owner);
                        addIfValid(moves, row+2*dir.row, col+1, owner);
                    } else {
                        addIfValid(moves, row-1, col+2*dir.col, owner);
                        addIfValid(moves, row+1, col+2*dir.col, owner);
                    }
                    break;
                    
                case 'lance':
                    for (let i = 1; i < 9; i++) {
                        const newRow = row + i * dir.row;
                        const newCol = col + i * dir.col;
                        if (newRow < 0 || newRow > 8 || newCol < 0 || newCol > 8) break;
                        if (board[newRow][newCol]) {
                            if (board[newRow][newCol].owner !== owner) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                        moves.push([newRow, newCol]);
                    }
                    break;
                    
                case 'pawn':
                    addIfValid(moves, row+dir.row, col+dir.col, owner);
                    break;
            }
            
            return moves;
        }

        function addIfValid(moves, row, col, owner) {
            if (row >= 0 && row < 9 && col >= 0 && col < 9) {
                if (!board[row][col] || board[row][col].owner !== owner) {
                    moves.push([row, col]);
                }
            }
        }

        function addLine(moves, row, col, owner, ...directions) {
            for (let [dr, dc] of directions) {
                for (let i = 1; i < 9; i++) {
                    const newRow = row + i * dr;
                    const newCol = col + i * dc;
                    if (newRow < 0 || newRow > 8 || newCol < 0 || newCol > 8) break;
                    if (board[newRow][newCol]) {
                        if (board[newRow][newCol].owner !== owner) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                    moves.push([newRow, newCol]);
                }
            }
        }

        // 成りが可能かチェック
        function canPromote(piece, fromRow, fromCol, toRow, toCol, owner) {
            if (!PIECES[piece].promoted) return false;
            
            switch(owner) {
                case 'player1':
                    return fromRow <= 2 || toRow <= 2;
                case 'player2':
                    return fromRow >= 6 || toRow >= 6;
                case 'player3':
                    return fromCol <= 2 || toCol <= 2;
                case 'player4':
                    return fromCol >= 6 || toCol >= 6;
            }
        }

        // 盤面を描画
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    if (selectedPos && selectedPos[0] === row && selectedPos[1] === col) {
                        cell.classList.add('selected');
                    }
                    
                    if (validMoves.some(([r, c]) => r === row && c === col)) {
                        cell.classList.add('valid-move');
                    }
                    
                    if (board[row][col]) {
                        const piece = document.createElement('div');
                        piece.className = `piece ${board[row][col].owner}`;
                        if (board[row][col].piece.includes('龍') || 
                            board[row][col].piece.includes('馬') ||
                            board[row][col].piece.includes('成') ||
                            board[row][col].piece === 'と金') {
                            piece.classList.add('promoted');
                        }
                        piece.textContent = PIECES[board[row][col].piece].abbr;
                        cell.appendChild(piece);
                    }
                    
                    cell.onclick = () => handleCellClick(row, col);
                    boardEl.appendChild(cell);
                }
            }
            
            // 持ち駒を表示
            renderCapturedPieces();
            
            // 手番表示
            const turnEl = document.getElementById('turnIndicator');
            const playerNum = currentTurn.replace('player', '');
            turnEl.textContent = `プレイヤー${playerNum}`;
            turnEl.className = `turn-indicator ${currentTurn}-turn`;
            
            // 待ったボタンの有効/無効
            document.getElementById('undoBtn').disabled = moveHistory.length === 0;
        }

        function renderCapturedPieces() {
            for (let i = 1; i <= 4; i++) {
                const player = `player${i}`;
                const el = document.getElementById(`${player}Captured`);
                el.innerHTML = '';
                
                capturedPieces[player].forEach((piece, index) => {
                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece captured-piece ${player}`;
                    pieceEl.textContent = PIECES[piece].abbr;
                    pieceEl.onclick = () => selectCapturedPiece(piece, index, player);
                    el.appendChild(pieceEl);
                });
            }
        }

        function selectCapturedPiece(piece, index, owner) {
            if (owner !== currentTurn) return;
            
            selectedPiece = { piece, capturedIndex: index, owner };
            selectedPos = null;
            validMoves = [];
            
            // 持ち駒を打てる場所を表示（空いているマス全て）
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (!board[row][col]) {
                        validMoves.push([row, col]);
                    }
                }
            }
            
            renderBoard();
        }

        function handleCellClick(row, col) {
            const cell = board[row][col];
            
            // 持ち駒を打つ
            if (selectedPiece && selectedPiece.capturedIndex !== undefined) {
                if (validMoves.some(([r, c]) => r === row && c === col)) {
                    // 履歴に保存
                    const move = {
                        type: 'drop',
                        piece: selectedPiece.piece,
                        to: [row, col],
                        player: currentTurn,
                        capturedIndex: selectedPiece.capturedIndex
                    };
                    moveHistory.push(move);
                    
                    board[row][col] = { 
                        piece: selectedPiece.piece, 
                        owner: currentTurn 
                    };
                    capturedPieces[currentTurn].splice(selectedPiece.capturedIndex, 1);
                    selectedPiece = null;
                    selectedPos = null;
                    validMoves = [];
                    nextTurn();
                    renderBoard();
                }
                return;
            }
            
            // 駒を選択
            if (!selectedPos) {
                if (cell && cell.owner === currentTurn) {
                    selectedPos = [row, col];
                    selectedPiece = cell;
                    validMoves = getValidMoves(row, col, cell.piece, cell.owner);
                    renderBoard();
                }
            } else {
                // 駒を移動
                if (validMoves.some(([r, c]) => r === row && c === col)) {
                    const [fromRow, fromCol] = selectedPos;
                    const capturedPiece = board[row][col];
                    
                    // 履歴に保存
                    const move = {
                        type: 'move',
                        from: [fromRow, fromCol],
                        to: [row, col],
                        piece: board[fromRow][fromCol].piece,
                        capturedPiece: capturedPiece ? {...capturedPiece} : null,
                        player: currentTurn,
                        promoted: false
                    };
                    
                    // 駒を取る
                    if (capturedPiece) {
                        let basePiece = capturedPiece.piece;
                        // 成駒を元に戻す
                        if (basePiece === '龍王') basePiece = '飛車';
                        else if (basePiece === '龍馬') basePiece = '角行';
                        else if (basePiece === '成銀') basePiece = '銀将';
                        else if (basePiece === '成桂') basePiece = '桂馬';
                        else if (basePiece === '成香') basePiece = '香車';
                        else if (basePiece === 'と金') basePiece = '歩兵';
                        
                        capturedPieces[currentTurn].push(basePiece);
                    }
                    
                    // 成りの確認
                    const piece = board[fromRow][fromCol];
                    if (canPromote(piece.piece, fromRow, fromCol, row, col, currentTurn)) {
                        if (confirm('成りますか？')) {
                            move.promoted = true;
                            move.originalPiece = piece.piece;
                            piece.piece = PIECES[piece.piece].promoted;
                        }
                    }
                    
                    board[row][col] = piece;
                    board[fromRow][fromCol] = null;
                    
                    moveHistory.push(move);
                    
                    selectedPos = null;
                    selectedPiece = null;
                    validMoves = [];
                    nextTurn();
                    renderBoard();
                } else if (cell && cell.owner === currentTurn) {
                    // 別の自分の駒を選択
                    selectedPos = [row, col];
                    selectedPiece = cell;
                    validMoves = getValidMoves(row, col, cell.piece, cell.owner);
                    renderBoard();
                } else {
                    // 選択解除
                    selectedPos = null;
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard();
                }
            }
        }

        function nextTurn() {
            // 時計回りに次のプレイヤー
            switch(currentTurn) {
                case 'player1': currentTurn = 'player4'; break;
                case 'player4': currentTurn = 'player2'; break;
                case 'player2': currentTurn = 'player3'; break;
                case 'player3': currentTurn = 'player1'; break;
            }
        }

        function previousTurn() {
            // 反時計回りに前のプレイヤー
            switch(currentTurn) {
                case 'player1': currentTurn = 'player3'; break;
                case 'player3': currentTurn = 'player2'; break;
                case 'player2': currentTurn = 'player4'; break;
                case 'player4': currentTurn = 'player1'; break;
            }
        }

        function undoMove() {
            if (moveHistory.length === 0) return;
            
            const lastMove = moveHistory.pop();
            previousTurn();
            
            if (lastMove.type === 'drop') {
                // 打った駒を戻す
                board[lastMove.to[0]][lastMove.to[1]] = null;
                capturedPieces[lastMove.player].splice(lastMove.capturedIndex, 0, lastMove.piece);
            } else {
                // 移動を戻す
                const [fromRow, fromCol] = lastMove.from;
                const [toRow, toCol] = lastMove.to;
                
                // 駒を元の位置に戻す
                let piece = lastMove.promoted ? lastMove.originalPiece : lastMove.piece;
                board[fromRow][fromCol] = {
                    piece: piece,
                    owner: lastMove.player
                };
                
                // 取った駒があれば戻す
                if (lastMove.capturedPiece) {
                    board[toRow][toCol] = lastMove.capturedPiece;
                    // 持ち駒から削除
                    let basePiece = lastMove.capturedPiece.piece;
                    if (basePiece === '龍王') basePiece = '飛車';
                    else if (basePiece === '龍馬') basePiece = '角行';
                    else if (basePiece === '成銀') basePiece = '銀将';
                    else if (basePiece === '成桂') basePiece = '桂馬';
                    else if (basePiece === '成香') basePiece = '香車';
                    else if (basePiece === 'と金') basePiece = '歩兵';
                    
                    const idx = capturedPieces[lastMove.player].indexOf(basePiece);
                    if (idx > -1) {
                        capturedPieces[lastMove.player].splice(idx, 1);
                    }
                } else {
                    board[toRow][toCol] = null;
                }
            }
            
            selectedPos = null;
            selectedPiece = null;
            validMoves = [];
            renderBoard();
        }

        function resetGame() {
            if (moveHistory.length > 0) {
                if (!confirm('ゲームをリセットしますか？')) return;
            }
            initBoard();
            selectedPiece = null;
            selectedPos = null;
            validMoves = [];
            document.getElementById('message').textContent = '';
            renderBoard();
        }

        // 初期化
        initBoard();
        renderBoard();
    </script>
</body>
</html>